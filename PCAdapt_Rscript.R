setwd("~/Desktop/Sarah/Salmon/GenomicVulnerability/")


site_info<- read.csv("SiteInfo/All_siteLocations_NorthAmerican_UPDATED.csv", header=T)

library(pcadapt)
library(ggplot2)
library(qqman)
library(qvalue)
library(ggrepel)
library(maps) # tool for maps
library(mapdata) # all your basemaps are here
library(marmap) # for bathymetry if needed
library(patchwork)
library(raster)
library(rgdal)

all_canada<- read.pcadapt("Combined_CAN_goodSNPs_allruns_badindremove_94K_updateIDs2_final_3838ind_maf005_recode.bed", type="bed")
canada_pca<- pcadapt(all_canada, K = 2, method =  "mahalanobis")
plot(canada_pca, option = "screeplot")

PCA_results <- canada_pca$scores
variance<- canada_pca$singular.values^2

fam=read.table("Combined_CAN_goodSNPs_allruns_badindremove_94K_updateIDs2_final_3838ind_maf005_recode.fam", header=F)

PCA_results_canada<- as.data.frame(cbind(fam, PCA_results))

head(PCA_results_canada)
colnames(PCA_results_canada)=c("Pop", "ind", "x", "y", "z", "m", "PC1", "PC2")


PCA_results_canada$Pop=as.factor(as.character(PCA_results_canada$Pop))

results_updated_northam<- merge(x=PCA_results_canada, y=site_info, by=1, all.x=T )
#View(results_updated_northam)

PC1_mean<-aggregate(PCA_results_canada$PC1~PCA_results_canada$Pop, FUN = "mean")
PC2_mean<-aggregate(PCA_results_canada$PC2~PCA_results_canada$Pop, FUN = "mean")
aggregate_means<-as.data.frame(cbind(PC1_mean, PC2_mean[,2]))
colnames(aggregate_means)=c("Pop", "PC1_mean", "PC2_mean")

pca_plot<- ggplot()+geom_point(data=results_updated_northam, aes(PC1, PC2, bg=Region), col="black", pch=21, size=2.5)+theme_bw()+
  scale_fill_manual(values=c("#ff7f00","#1f78b4","#ffff33","darkorchid1","#33a02c","#e31a1c", "black", "hotpink"))+ylab(paste0("PC2 (", round(variance[2]*100,2), "%)"))+
  xlab(paste0("PC1 (", round(variance[1]*100,2), "%)"))+
 # geom_text_repel(data=(aggregate_means), aes(PC1_mean, PC2_mean, label=Pop),
   #               segment.size  = 1,
    #              segment.color = "black",
                  #direction     = "y",
                 #hjust         = 1,
    #              col="black", size=5) 
NULL

ggplot()+geom_text(data=aggregate_means, aes(PC1_mean, PC2_mean, label=Pop))+theme_bw()+
  #scale_fill_manual(values=c("#ff7f00","#1f78b4","#ffff33","darkorchid1","#33a02c","#e31a1c", "black", "hotpink"))+ylab(paste0("PC2 (", round(variance[2]*100,2), "%)"))+
  xlab(paste0("PC1 (", round(variance[1]*100,2), "%)"))
  NULL

current_data<-as.data.frame(table(results_updated_northam$Pop))
current_data_sites<-merge(current_data, site_info, by=1)

#Plot map
#See autoplot below for nicer map

world <- map_data("world")

map_plot<-ggplot()+ 
  geom_map(data=world, map=world,
           aes(x=long, y=lat, map_id=region),
           color="gray60", size=0.1, fill="gray")+
  scale_x_continuous(limits = c(-72,-50), expand = c(0, 0)) +
  scale_y_continuous(limits = c(42,58), expand = c(0, 0)) +
  theme_bw()+theme(panel.grid = element_blank())+
  geom_point(data=current_data_sites, aes(Long, Lat, fill=Region, size=Freq),
             col="black", pch=21)+
  scale_fill_manual(values=c("#ff7f00","#1f78b4","#ffff33","darkorchid1","#33a02c","#e31a1c", "black", "hotpink"))+
  geom_text_repel(data=current_data_sites, aes(Long, Lat, label=Var1), 
                  size=3)+
  NULL

#with patchwork
map_plot/pca_plot


#########Coordindate range for the map
Sample.Lat.lim=c(42, 58)
Sample.Long.lim=c(-50,-72)

#Now get a bathy map for Canada area (use same coordinates as above) - Approximately Maine to Northern Labrador/QC
getNOAA.bathy(-50,-72,42,58, res=1,keep=T)->bathydata

#Can save as PDF with this - optional (use with dev.off() below if saving)
#pdf(file="Map_autoplot_Canada.pdf", width = 13, height=12, bg = "white")

#Plot map
map=autoplot(bathydata, geom=c("r", "c"), colour="grey", size=0.1) +
  scale_fill_etopo() +
  geom_contour(aes(z=z), breaks=c(-100, -200, -500, -1000, -2000, -4000), colour="grey90", size=0.01) +
  xlab("Longitude") +
  ylab("Latitude") +
  theme(legend.position = "none")

#make sure there are no coordinates (populations) outside of map region (otherwise it will add those too without map area )
#See function below for adding new colour scale!!
autoplot_map<- map + new_scale_fill() +
  geom_point(data=current_data_sites, aes(Long, Lat, fill=Region, size=Freq), col="black", pch=21)+
  scale_size(  range = c(2, 7)  )+
  scale_fill_manual(values=c("#ff7f00","#1f78b4","#ffff33","darkorchid1","#33a02c","#e31a1c", "black", "hotpink"))
  
#with patchwork
autoplot_map/pca_plot


##check manhattan plots

bim<-read.table("Combined_CAN_goodSNPs_allruns_badindremove_94K_updateIDs2_final_3838ind_maf005_recode.bim", header=F)
bim_pvals <- as.data.frame(cbind(bim, canada_pca$pvalues ))
head(bim_pvals)
colnames(bim_pvals)<- c("Chr", "SNP", "x", "Pos", "a", "b", "pval")

convt_q<- qvalue(bim_pvals$pval)
convt_q$qvalues

bim_pvals$qvals<- convt_q$qvalues

which.min(bim_pvals$qvals)
#View(bim_pvals)
bim_pvals[order(bim_pvals$qvals, decreasing = F),]

bim_pvals=bim_pvals[!is.na(bim_pvals$qvals),]

manhattan(x = bim_pvals[!is.na(bim_pvals$Chr),], cex=0.7,  col=c("gray50", "dodgerblue4"),
          chr = "Chr", bp = "Pos", snp = "SNP", ylab="-log10(qvalue)",
          p = "qvals", suggestiveline = F, genomewideline = F)

############################################################################################################
###functions for adding multiple fill scales from https://gist.github.com/eliocamp/eabafab2825779b88905954d84c82b32
new_scale <- function(new_aes) {
  structure(ggplot2::standardise_aes_names(new_aes), class = "new_aes")
}

#' Convenient functions
new_scale_fill <- function() {
  new_scale("fill")
}

new_scale_color <- function() {
  new_scale("colour")
}

new_scale_colour <- function() {
  new_scale("colour")
}

#' Special behaviour of the "+" for adding a `new_aes` object
#' It changes the name of the aesthethic for the previous layers, appending
#' "_new" to them. 
ggplot_add.new_aes <- function(object, plot, object_name) {
  plot$layers <- lapply(plot$layers, bump_aes, new_aes = object)
  plot$scales$scales <- lapply(plot$scales$scales, bump_aes, new_aes = object)
  plot$labels <- bump_aes(plot$labels, new_aes = object)
  plot
}


bump_aes <- function(layer, new_aes) {
  UseMethod("bump_aes")
}

bump_aes.Scale <- function(layer, new_aes) {
  old_aes <- layer$aesthetics[remove_new(layer$aesthetics) %in% new_aes]
  new_aes <- paste0(old_aes, "_new")
  
  layer$aesthetics[layer$aesthetics %in% old_aes] <- new_aes
  
  if (is.character(layer$guide)) {
    layer$guide <- match.fun(paste("guide_", layer$guide, sep = ""))()
  }
  layer$guide$available_aes[layer$guide$available_aes %in% old_aes] <- new_aes
  layer
}

bump_aes.Layer <- function(layer, new_aes) {
  original_aes <- new_aes
  
  old_aes <- names(layer$mapping)[remove_new(names(layer$mapping)) %in% new_aes]
  new_aes <- paste0(old_aes, "_new")
  
  old_geom <- layer$geom
  
  old_setup <- old_geom$handle_na
  new_setup <- function(self, data, params) {
    colnames(data)[colnames(data) %in% new_aes] <- original_aes
    old_setup(data, params)
  }
  
  new_geom <- ggplot2::ggproto(paste0("New", class(old_geom)[1]), old_geom,
                               handle_na = new_setup)
  
  new_geom$default_aes <- change_name(new_geom$default_aes, old_aes, new_aes)
  new_geom$non_missing_aes <- change_name(new_geom$non_missing_aes, old_aes, new_aes)
  new_geom$required_aes <- change_name(new_geom$required_aes, old_aes, new_aes)
  new_geom$optional_aes <- change_name(new_geom$optional_aes, old_aes, new_aes)
  
  layer$geom <- new_geom
  
  old_stat <- layer$stat
  
  old_setup2 <- old_stat$handle_na
  new_setup <- function(self, data, params) {
    colnames(data)[colnames(data) %in% new_aes] <- original_aes
    old_setup2(data, params)
  }
  
  new_stat <- ggplot2::ggproto(paste0("New", class(old_stat)[1]), old_stat,
                               handle_na = new_setup)
  
  new_stat$default_aes <- change_name(new_stat$default_aes, old_aes, new_aes)
  new_stat$non_missing_aes <- change_name(new_stat$non_missing_aes, old_aes, new_aes)
  new_stat$required_aes <- change_name(new_stat$required_aes, old_aes, new_aes)
  new_stat$optional_aes <- change_name(new_stat$optional_aes, old_aes, new_aes)
  
  layer$stat <- new_stat
  
  layer$mapping <- change_name(layer$mapping, old_aes, new_aes)
  layer
}

bump_aes.list <- function(layer, new_aes) {
  old_aes <-  names(layer)[remove_new(names(layer)) %in% new_aes]
  new_aes <- paste0(old_aes, "_new")
  
  names(layer)[names(layer) %in% old_aes] <- new_aes
  layer
}

change_name <- function(list, old, new) {
  UseMethod("change_name")
}

change_name.character <- function(list, old, new) {
  list[list %in% old] <- new
  list
}

change_name.default <- function(list, old, new) {
  nam <- names(list)
  nam[nam %in% old] <- new
  names(list) <- nam
  list
}

change_name.NULL <- function(list, old, new) {
  NULL
}

remove_new <- function(aes) {
  stringi::stri_replace_all(aes, "", regex = "(_new)*")
}

